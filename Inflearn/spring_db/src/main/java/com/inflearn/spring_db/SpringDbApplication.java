package com.inflearn.spring_db;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringDbApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringDbApplication.class, args);
	}
}

// JDBC 이해
//	- JDBC 등장 이유
//		- 일반적으로 app이나 브라우저에서 직접 data access하지 않음. -> was를 거침.
//  	- 주로 was에서 db에 커넥션을 연결하고 sql을 보낸 후 결과를 응답 받음.
//		- 엄청 옛날에는 db마다 연결과 요청을 위한 스펙이 다 달랐음. -> db가 변경되면?? -> 모든 코드 바뀜.
//			- 그럼 각 db마다 따로 스펙을 학습해야함. -> 그래서 JDBC 등장.
//	- JDBC 표준 인터페이스 (Java Database Connectivity)
//		- 자바에서 DB에 접속할 수 있도록 하는 자바 API, JDBC는 DB에서 자료를 쿼리하거나 update하는 방법 제공.
//		- 대표적으로 연결(java.sql.Connection), SQL 담은 내용(java.sql.Statement), SQL 요청 응답(java.sql.ResultSet)
//		  을 표준 인터페이스로 정의해서 제공.
//		- 이제부터 이 표준 인터페이스만 따라서 개발하면 됨. -> 각 DB 벤더에서 자신의 DB에 맞도록 구현 후 라이브러리 제공 -> JDBC Driver
//	- 정리
//		- JDBC 등장으로 2가지 문제 해결
//			1. DB가 변경되는 경우 코드 모두 변경 -> JDBC 표준 인터페이스에만 의존해서 구현이 바뀌어도 상관 X
//			2. 개발자가 JDBC 표준 인터페이스만 공부하면 모든 구현체 사용가능.
//	< 참고 - 표준화의 한계 >
//		- DB마다 SQL 문법, 데이터 타입 등의 일부 사용법 상이. -> JDBC 코드는 변경 X but, SQL은 변경해야함.
//		- JPA는 각 DB 마다의 다른 SQL을 정의해야 하는 문제도 많은 부분 해결 가능.
//	- JDBC와 최신 데이터 접근 기술
//		- 최근에는 JDBC를 더 편리하게 다양한 기술들 존재.
//			- SQL Mapper (JDBC Template, MyBatis)
//				- 장점 : JDBC를 편리하게 사용하도록 도움.
//					- SQL 응답 결과를 객체로 편리하게 변환.
//					- JDBC의 반복 코드를 제거.
//				- 단점 : 개발자가 SQL을 직접 작성.
//			- ORM 기술 (JPA - 하이버네이트, 이클립스링크)
//				- ORM은 객체를 RDB 테이블과 매핑해주는 기술. 이 덕분에 개발자는 반복적인 SQL을 직접 작성 X
//				  ORM 기술이 대신 SQL 동적으로 만들어 실행, 각각의 DB마다 다른 SQL 사용하는 문제도 중간에서 해결.
//			- SQL Mapper vs ORM 기술
//				- 각각의 장단점 존재
//					- SQL Mapper : SQL만 직접 작성 -> 나머지 번거로운 일 SQL Mapper가 해결해줌. SQL만 작성할 줄 알면
//								  쉽게 사용할 수 있음.
//					- ORM 기술 : 개발 생산성 증가 -> but 쉬운 기술 X, 깊이있는 학습 필요.
//		- 중요한건 이런 기술들 전부 내부적으로 JDBC 사용 -> JDBC 직접 사용하지 않아도 어떻게 동작하는지 기본 원리 학습 필요.
//		- 그래야 해당 기술들을 더 깊이있게 이해 가능하고 무엇보다 문제 발생 시 근본적인 문제를 찾아 해결 가능.

// 커넥션 풀 이해
//	- DB 커넥션을 매번 획득 -> 커넥션 획득 시 내부적으로 다음 과정을 거침.
//		1. 로직이 DB 드라이버를 통해 커넥션 조회.
//		2. DB 드라이버는 DB와 TCP/IP 커넥션 연결
//		3. DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달.
//		4. DB ID, PW를 인증완료하고 내부에 DB 세션을 생성.
//		5. DB는 커넥션 생성이 완료되었다는 응답.
//		6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환.
// 		=> 이런 과정은 매우 복잡하고 시간도 많이 소모. -> 커넥션 생성을 위한 리소스를 매번 사용.
// 		=> 진짜 문제는 애플리케이션 사용 시 SQL 실행 시간 외에 커넥션 생성 시간이 추가됨. -> 응답 속도에 영향.
//		<> DB마다 커넥션을 생성하는 시간이 다름 -> MySQL은 수밀리초 안에 끝남 -> but 수십밀리초가 걸리는 DB도 존재.
//	- 이를 해결하기 위해서 커넥션을 미리 생성해두고 사용하는 방법이 커넥션 풀이라는 방법.
//		- 애플리케이션이 뜰때 보통 기본값으로 10개를 생성하고 커넥션 풀에 담아둠.
//		- 풀에서 꺼내쓰면 이미 연결되어있기에 바로 SQL을 날릴 수 있음.
//		- 커넥션 풀 사용 1
//			- 로직에서 DB 드라이버를 통해 새로운 커넥션을 생성 X
//			- 커넥션 풀의 커넥션을 가져와서 씀 -> 커넥션 풀에 요청 -> 커넥션을 응답받음.
//		- 커넥션 풀 사용 2
//			- 받은 커넥션을 통해 SQL을 DB에 전달
//			- 사용 후 커넥션을 닫으면 안됨. -> 그대로 (살아있는 상태) 커넥션 풀에 다시 반환.
//	- 정리
//		- 커넥션 풀 숫자는 서비스 특징과 서버 스펙, DB 서버 스펙에 따라 다름. -> 테스트를 통해 정하기
//		- 최대 커넥션 수를 제한 -> DB에 무한정 연결이 생성되는 것을 막아서 DB를 보호.
//		- 커넥션 풀은 단순해서 직접 구현 가능 -> But, 사용도 편리하고 성능도 뛰어난 오픈소스들이 많아서 그 중 하나 선택하는것이 훨씬 나은 방법.
//		- 많은 오픈소스가 있지만 지금은 HikariCP를 쓰면 됨. -> 스프링 부트 2.0부터는 이를 기본 커넥션 풀로 가져감. -> 안정성 측면에서 이미 검증됨.

// DataSource 이해
//	- 커넥션 얻는 방법 -> DriverManager 직접 사용, 커넥션 풀 사용 등 다양한 방법 존재.
//	- 그럼 앞서 DriverManager를 통해 커넥션 획득하다가 커넥션 풀 사용하는 방법으로 바꿀려면 어떻게 하지??
//		- 애플리케이션 로직에서 코드 수정이 필요. -> 물론 둘의 사용방법도 조금은 다르기에 이에 대한 수정도 필요. (구현체에 대한 직접 의존 때문)
//	- 커넥션 획득 방법을 추상화
//		- 자바에서는 이런 문제 해결을 위해서 java.sql.DataSource 라는 인터페이스 제공.
//		- DataSource는 커넥션을 획득하는 방법을 추상화 하는 인터페이스임.
//		- 핵심 기능은 커넥션 조회 하나임 -> 다른 기능도 있지만 중요 X
//	- 정리
//		- DataSource에 의존하게 애플리케이션 로직 작성 -> OCP
//		- 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 갈아끼우기.
//		- 사실 DriverManager는 DataSource 인터페이스를 사용하지 않음. -> 따라서 직접 DriverManager 직접 사용. -> 코드 변경 필요.
//		- 이를 해결하기 위해서 스프링은 DriverManagerDataSource라고 DatSource를 구현한 클래스를 제공함.
