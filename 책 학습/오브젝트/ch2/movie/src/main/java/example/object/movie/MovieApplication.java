package example.object.movie;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MovieApplication {

	public static void main(String[] args) {
		SpringApplication.run(MovieApplication.class, args);
	}

}

// 상속과 다형성
//	- 구현된 Movie 클래스에선 어떻게 할인 정책을 결정하는 조건문 없이 할인 정책의 구현체를 선택할 수 있었을까?
//	- 이를 위해선 상속과 다형성에 대해서 알아야한다. 일단 의존성에 대해서 공부해보자.
//	- 컴파일 시간 의존성과 실행 시간 의존성
//		- Movie에서 할인 정책을 사용하려면 구현체들에 의존해야 하는데 여기선 인터페이스에만 의존하고 있다.
//		- 어떻게 Movie가 코드 작성 시점에서는 존재를 모르던 구현체들을 실행 시점엔 협력할 수 있을까?
//		- 사용하고 싶은 구현체를 Movie를 생성할 때 삽입하면 코드에서 구현체엔 의존하지 않지만 실행 시점에 의존하게 된다. -> 여기서 말하고 싶은건 코드의 의존성과 실행 시점에서의 의존성이 다를 수 있다는 것이다.
//		- 한 가지 간과하면 안되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다. -> 다를수록 유연성과 확장성은 좋아지지만 가독성이 안좋아지는 트레이드오프의 산물이다.
//	- 차이에 의한 프로그래밍
//		- 클래스 추가 시 기존의 어떤 클래스와 매우 흡사하다고 가정하면 그 클래스의 코드를 수정하지 않고 재사용하면 참 좋을 것이다. -> 상속. -> 상속은 코드 재사용을 위해 가장 널리 사용되는 방법이다.
//		- 상속 이용 시 기존 클래스가 가지고 있던 속성과 행동을 새로운 클래스에 포함시킬 수 있다. -> 부모의 구현은 공유하고 자식의 행동은 쉽게 추가할 수 있다.
//		- 이와 같이 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라고 부른다.
//	- 상속과 인터페이스
//		- 상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. -> 메서드나 인스턴스 변수를 재사용이 목적이 아니다.
//			- 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억해라.
//		- 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기에 부모 클래스와 동일한 타입으로 간주할 수 있다. -> 컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
//		- 위와 같은 이유로 구현 클래스를 몰랐는데도 이용할 수 있었던 것이다.
//		- 이런 상황처럼 자식이 부모를 대신하는 경우를 업캐스팅이라고 하고 그 ㄷ반대를 다운캐스팅이라고 한다.
//	- 다형성
//		- 메시지와 메서드는 다른 개념이다. -> DiscountPolicy에게 메시지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 Movie와 협력하는 객체의 실제 클래스가 뭔지에 따라 달라진다.
//		- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지고 이를 다형성이라고 부른다.
//		- 다형성은 코드의 의존성과 실행 시점의 의존성이 다를 수 있다는 사실을 기반으로 한다. -> 이런 객체지향의 특성을 이용해서 서로 다른 메서드를 실행할 수 있게 한다. -> 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력 -> 다형성.
//		- 따라서 다형적 협력에 참여하는 객체들은 동일한 메시지를 이해할 수 있어야 한다. -> 인터페이스가 동일해야함. -> 우리는 이 인터페이스를 통일하기 위해서 상속이란 방법을 이용했음.
//		- 다형성을 구현하는 방법은 많지만 메시지에 응답하기 위해 실행될 메서드를 실행 시점에 결정한다는 공토점이 있고 이를 지연 바인딩 혹은 동적 바인딩이라고 부른다.
//		- 반면 컴파일 시점에 결정하는 것을 초기 바인딩 혹은 정적 바인딩이라고 부른다.
//		- 다형성을 설명할 때 이와 같은 이유로 상속이 함께 나오지만 상속만이 인터페이스를 동일하게 만드는 방법이 아니고 다형성을 이용할 수 있는 방법이 아니다. -> 꽤나 다양하다. 나중에 배워보자.
//	- 구현 상속과 인터페이스 상속
//		- 상속은 구현 상속과 인터페이스 상속으로 나눌 수 있고 구현 상속은 순수한 코드의 재사용을 목적으로 하고 인터페이스는 부모 클래스의 인터페이스를 자식 클래스가 공유하기 위한 목적으로 이용한다.
//		- 상속은 인터페이스 상속을 위해서 사용해야 한다.  -> 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다. (ex. extends)
//	- 인터페이스와 다형성
//		- 순수하게 인터페이스만 공유하고 싶은 경우를 위해 자바에서는 인터페이스라는 프로그래밍 요소를 제공한다. -> 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것.
//	- 추상화와 유연성
//		- DiscountPolicy, DiscountCondition이 구현체들보다 추성작인 이유는 인터페이스에 초점을 맞추기 때문. -> 이들은 모든 할인 정책과 조건들이 수신할 수 있는 메시지에 대한 인터페이스를 정의함. -> 구현의 일부 또는 전체가 자식 클래스를 결정하도록 결정권 위임.
//		- 이 코드들을 통해서 추상화를 사용할 경우의 두 가지 장점을 볼 수 있음.
//			1. 추상화의 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있음.
//				- 영화 예매 요금은 최대 하나의 할인 정책과 다수의 할인 조건을 이용해 계산할 수 있다.
//				- 위 문장이 금액 할인 정책과 두 개의 순서 조건, 한개의 기간 조건을 이용해서 계산할 수 있다는 문장을 포관할 수 있다는 것이 중요함. -> 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중욯나 개념을 설명할 수 있음.
//				- 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미.
//				- 이 개념은 매우 중요한데, 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용해서 상위 정책을 정의하는 객체지향 메커니즘을 활용하고 있기 때문.
//			2. 추상화를 이용하면 더 유연해짐.
//	- 코드 재사용
//		- 상속은 코드를 재사용하기 위해 널리 사용되는 방법이지만 가장 좋은 방법은 아니다. -> 코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이다. -> 이는 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.
//		- 왜 많은 사람들이 상속대신 합성을 선호할까?
//			- 상속은 코드 재사용을 위해서 많이 사용되지만 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
//				1. 상속이 캡슐화를 위반한다. -> 이게 가장 큰 문제점이다. -> 상속을 이용하기 위해선 부모 클래스의 내부 구조를 잘 알고 있어야 한다. -> 결과적으로 부모 클래스의 구현이 자식 클래스에게 노출 -> 캡슐화가 약화되고 자식 클래스가 부모 클래스에 강하게 결합된다.
//					-> 그럼 부모 클래스의 변경에서 자식 클래스도 변경될 확률을 높인다.
//				2. 설계를 유연하지 못하게 만든다. -> 상속은 부모와 자식 사이의 관계를 컴파일 시점에 결정한다. -> 실행 시점에 객체의 종류 변경이 불가능하다.
//					- 상속을 사용한 설계에서 AmountDiscountMovie의 인스턴스를 PercentDiscountMovie의 인스턴스로 변경해야 한다. -> 대부분의 언어는 이미 생성된 객체의 클래스를 변경하는 기능을 지원하지 않아 PercentDiscountMovie의 인스턴스를 만들고
//						AmountDiscountMovie의 상태를 복사한다. -> 이게 부모 클래스와 자식 클래스가 강하게 결합돼 있기 때문에 발생하는 문제다.
//					- 반면 인스턴스 변수로 연결한 기존 방법을 이용하면 실행 시점에 할인 정책을 간단히 변경할 수 있따. ->  아래 코드와 같이 말이다.
//						public void changeDiscountPolicy(DiscountPolicy discountPolicy) {
// 							this.discountPolicy = discountPolicy;
// 						}
// 	- 합성
//		- Movie는 요금 계산을 위해서 DiscountPolicy 코드를 재사용하는데 상속과 다른 점은 Movie가 DiscountPolicy의 인터페이스를 통해 약하게 결합된다는 것이다.
//		- 실제로 Movie는 인터페이스만을 보고 이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다.
//		- 상속이 가지는 두 가지 문제점을 합성은 모두 해결한다.-> 코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
//		- 그렇다고 상속을 절대 사용하지 말라는 것은 아니다. -> 상속과 합성을 함께 사용해야 한다. -> Movie와 DiscountPolicy는 합성, DiscountPolicy와 AmountDiscountPolicy, PercentDiscountPolicy는 상속.
//		- 이처럼 코드 재사용을 위해선 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다.
//		- 객체지향의 본질을 놓치지 말자 -> 객체지향이란 객체를 지향하는 것이다. -> 패러다임의 중심에는 객체가 위치한다. -> 그러나 각 객체를 따로 떼어 놓고 이야기하는 것은 무의미하다. -> 가장 중욯나 것은 애플리케이션 기능 구현을 위해 협력에 참여하는 객체 간의 상호작용이다.
//		- 객체는 협력에 참여하기 위해서 역할을 부여받고 역할에 적합한 책임을 수행한다. -> 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.
