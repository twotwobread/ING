상속과 합성은 가장 널리 사용되는 코드 재사용 기법이다. 상속은 부모 클래스의 코드를 재사용하지만 합성은 부모 클래스의 퍼블릭 인터페이스를 재사용한다. 그래서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.

# 상속을 합성으로 변경하기

앞선 장에서 상속을 남용했을 때 발생하는 문제점 3가지를 알아봤다.

- 불필요한 인터페이스 상속 문제
    - 이는 합성을 이용하면 기존 문제였던 불필요한 메서드를 이용하지 않으면 문제를 해결할 수 있다
    - 그니까 합성으로 가진 인스턴스 변수의 객체를 이용해서 퍼블릭 인터페이스를 이용한 협력을 내가 원하는 메서드랑만 수행하면 된다
- 메서드 오버라이딩의 오작용 문제
    - 해당 문제 또한 내가 만들고자 하는 기능응 만들면 된다
    - 앞에꺼와 다른부분은 이는 모든 퍼블릭 인터페이스를 오버라이딩해서 구현해준다는 것이다. 이와 같이 오버라이딩한 인스턴스 메서드에서 내부의 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 포워딩이라 부르고 동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드라 부른다
- 부모 클래스와 자식 클래스의 동시 수정 문제
    - 합성으로 변경해도 가수별 노래 목록을 유지 하기 위해 동시 수정을 해야하는 문제는 해결되지 않는다.
    - 그래도 합성을 사용하는 것이 좋은데 향후에 내부 구현을 변경해도 파급효과를 줄 일 수 있기 때문이다.

해당 부분에서 합성의 장점 중 하나인 안정성을 살펴봤다. 이제는 유연성을 살펴보자

# 상속으로 인한 조합의 폭발적인 증가

상속으로 인해 결합도기 높아지면 코드 수정 시 작업의 양이 매우 늘어난다.

### 기본 정책과 부가 정책 조합하기

요구사항이 추가된다고 가정해보자. 기본 정책에 일반 요군제와 심야 할인 요금제가 존재하고 부가정책으로 세금 정책과 기본 요금 할인 정책이 존재한다.

부가 정책의 특성은 다음과 같다

- 기본 정책의 계산 결과에 적용된다
- 선택적으로 적용할 수 있다
- 조합 가능하다
- 부가 정책은 임의의 순서로 적용 가능하다

결국 가능한 조합의 수가 진짜 다양하다. 이를 수용할 수 있도록 유연해야 한다.

### 상속을 이용해서 기본 정책 구현하기

Phone을 상속받는 RegularPhone과 NightlyDiscountPhone은 그대론데 이는 기본 정책만을 의미한다.

### 기본 정책에 세금 정책 조합하기

각 기본 정책을 상속받는 TaxableRegularPhone과 TaxableNightlyDiscountPhone을 추가하자.

추상화에 의존하기 위해서 부모 클래스에 추상 메서드를 추가하면 모든 자식들이 추상 메서드를 오버라이딩해야 하는 문제가 발생한다. 유연성을 유지하면서 중복 코드를 제거하기 위해서 일부 메서드에 대한 구현을 부모 클래스에서 제공한다.

- 훅 메서드 : 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해서 기본 구현을 제공하는 메서드를 훅 메서드라고 부름.

여기서 문제는 추가된 TaxableRegularPhone과 TaxableNightlyDiscountPhone에서 코드가 중복된다는 것이다. 이름을 제외하면 거의 동일하다. 자바를 비롯한 대부분의 객체지향 언어가 단일 상속민 지원해서 상속으로 인해 발생하는 중복 코드 문제를 해결하기 쉽지 않다.

### 기본 정책에 기본 요금 할인 정책 조합하기

부가 정책 중 하나인 기본 요금 할인 정책을 기본 정책에 추가하려면 또 두 개의 클래스를 만들어야 하는데 이또한 두 클래스가 거의 동일할 것이다.

### 중복 코드의 덫에 걸리다

부가 정책은 자유롭게 조합할 수 있고 순서 역시 임의로 결정할 수 있어야 한다.

상속을 이용한 해결 방법은 모든 가능한 조합별로 자식 클래스를 하나씩 추가하는 방식이다. 꽤 복잡해진다. 

하지만 복잡성 보다 더 큰 문제는 새로운 정책 추가가 어렵다는 것이다. 새로운 정책을 추가하기 위해선 불필요하게 많은 수의 클래스를 상속 계층에 추가해야 한다.

새로운 정책 FixedRatePhone을 추가한다고 가정하면 이 정책을 이용한 가능한 모든 경우의 조합 클래스들을 상속 계층에 추가해

이처럼 상속의 남용으로 하나의 기능 추가를 위해서 필요 이상으로 많은 클래스가 추가되어야 하는 문제를 클래스 폭발 문제라고 한다. 이는 기능 수정에서도 만제가 되는데 하나의 정책을 고치면 거기에 중복된 다른 정책들도 고쳐져야 한다.

# 합성 관계로 변경하기

합성은 컴파일타임 관계를 런타임 관계로 바꿔서 해결한다. 퍼블릭 인터페이스에만 의존하므로 런타임에 해결이 가능하다.

상속이 조합위 결과를 개별 클래스 안으로 밀어 넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법을 이용한다.

### 기본 정책 합성하기

RatePolicy라는 인터페이스를 추가하는데 이는 Phone을 인자로 받아 계산된 요굼을 반환하는 calculateFee 오퍼레이션을 포함하는 간단한 인터페이스이다.

이를 구현하는 BasicRatePolicy를 생성하는데 이는상속버전의 Phone이다.  이를 상속하는 일반 요굼제와 심야 요굼제를 구현한다. 이제 기본 정책을 합성으로 가지는 Phone이란 객체를 만들자. 인터페이스를 가져서 추상화에 의존하게 만들자. 

### 부가 정책 적용하기

부가 정책은 RatePolicy를 구현해야 하며 내부에 또 다른 RatePolicy를 합성할 수 있어야 한다. 그래서 내부에 next란 이름의 RatePolicy를 인스턴스 변수로 가진다. 이를 AdditionalRatePolicy라고 구현하고 이를 상속하는 세금 정책과 기본 요금 할인 정책을 추가하자.

### 기본 정책과 부가 정책 합성하기

남은 일은 원하는 정책의 인스턴스를 생성한 후 의존성 주입을 통해 다른 정책의 인스턴스를 전달하는 것뿐이다

상속을 사용한 방식보다 오히려 더 예측가능하고 일괸성있다 하지만 합성의 진가는 새로운 클래스를 추가하거나 수정할때 비로소 알 수 있다

### 새로운 정책 추가하기

FixedRatePhone을 추가한다고 가정하자. AdditionalRatePolicy를 상속받게 하나의 클래스만 만들면 된다. 우리는 런타임에 가지고 있는 정책들을 조합하기만 하면 된다.

더 중요한 것은 요구사항 젼경 시 오직 하나의 클래스만 수정해도 된다는 것이다. 변경 후의 설계는 SRP를 준수하고 있다는 것이다

# 믹스인

믹스인은 객체 생성 시 코드 일부를 클래스 내부에 섞어 넣어 재사용하는 기법을 일컫는다. 합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.

상속은 is-a 관계를 만들기 위한 것이지만 믹스인은 말 그대로 섞어 넣기위한 방법이다. 믹스인은 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법이다.

자바에선 지원 x 

믹스인은 상속에 비해 코드 재사용과 확장의 관점에서 굉장히 편리하다. 재사용 가능한 코드를 독립적으로 작성한 후 필요한 곳에서 쉽게 조합할 수 있게 해준다.

사람들은 믹스인을 사용해도 어짜피 클래스가 기하급수적으로 늘어나는 클래스 폭발 문제가 발생할 수 있지 않냐고 하지만 사실 클래스 폭발의 단점은 클래스가 늘어나는 것이 아니라 클래스가 늘어남으로써 중복 코드가 늘어난다는 점이다. 믹스인은 그렇지 않다.
