package example.object.ch1;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Ch1Application {

	public static void main(String[] args) {
		SpringApplication.run(Ch1Application.class, args);
	}

}

// 이 코드는 간단하고 예상대로 동작하지만 몇 가지 문제점이 있다.
// 예상을 빗나가는 코드
//	- 먼저 Theater 클래스의 enter 메소드가 수행하는 일을 말로 풀어보자.
//		- 소극장은 관람객의 가방을 열어 초대장 유무를 확인.
//			- 존재하면 티켓을 관람객의 가방으로 옮김.
//			- 없으면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내서 매표소에 적립하고 티켓을 가방으로 옮김.
//		- 여기서의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재하는 점이다.
//		- 자, 관람객의 입장에서 누군가 마음대로 내 가방을 뒤적이는데 멍하니 바라만 볼것인가?
//		- 마찬가지로 판매원도 소극장이 매표소에 보관 중인 티켓과 현금을 마음대로 가져가게 바라만 볼것인가?
//	- 이해가능한 코드란 우리의 예상을 벗어나지 않는 코드이다. -> 지금 코드는 우리 예상을 벗어난다.
//	- 현실에서는 관람객과 판매원이 자율적이고 능동적으로 다른 객체와 소통을 해야한다. -> 지금 코드는 우리의 상식과 너무도 다르게 동작하기에 코드를 읽는 사람과 제대로 의사소통 할 수 없다.
//	- 또 코드 이해가 어려운 이유는 이 코드를 이해하기 위해선 많은 것을 기억해야 한다.
//		- Audience가 Bag을 가지고 있고 Bag 안에는 현금과 티켓이 있으며 TicketSeller가 TicketOffice에서 티켓을 판매하고 TicketOffice에 돈과 티켓이 존재한다.
//		- 하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 코드를 일고 이해해야 하는 사람 모두에게 큰 부담을 준다.
//	- 가장 심각한 문제는 Audience와 TicketSeller가 변경될 경우 Theater도 함께 변경해야 한다는 것이다.
// 변경에 취약한 코드
//	- 이 코드는 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다니다고 가정한다. -> 가방이 없다면? 혹은 현금이 아닌 신용카드를 이용한다면>
//	- 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다. -> 매표소 밖에서 티켓을 판매해야 한다면?
//	=> 가정이 깨지면 모든 코드가 흔들린다.
//	=> Theater는 관람객이 가방을 들고 있고 판매원이 매표소에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다.
// 	- 이것은 객체 사이의 의존성과 관련된 문제이다. -> 의존성은 변경에 대한 영향을 암시한다. -> 어떤 객체 변경 시 다른 객체도 변경.
//	- 그렇다고 객체 사이의 의존성을 완전히 없애는 것은 정답은 아니다. -> OOP 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.
// 	- 그래서 목표는 최소한의 의존성만 유지하고 불필요한 의존성은 제거하는 것이다.
//	- 이렇게 객체 사이의 의존성이 과한 경우를 결합도가 높다고 말한다. -> 결합도가 높으면 함께 변경될 확률도 높아지기에 변경이 어려워진다.

// 설계 개선하기
//	- 지금 코드를 이해하기 어려운 이유는 소극장이 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. -> 의도를 정확하게 의사소통 X -> 코드 이해 어려움.
// 	- Theater가 직접 접근하니까 관람객과 판매원과 의존한다. -> 의존하는 객체들 변경 시 소극장도 변경 -> 소극장이 세세한 정보를 알지 못하게 차단하기.
//	- Theater가 원하는 의도에 대해서 메시지로 표현하면 '소극장에 입장해라'이고 그 주체는 관람객이다. -> 관람객이 스스로 현금과 초대장 처리, 판매원이 스스로 티켓, 요금 처리

// 무엇이 개선됐는가?
//	- 의사소통 -> 관람객과 판매원이 자신이 가지고 있는 소지품을 스스로 관리한다. -> 우리의 예상과 딱 맞다. -> 기능을 유추할 수 있다.
//	- 변경 용이성 -> 관람객과 판매원이 변경되어도 소극장이 변경되지 않아도 된다.
// 어떻게 한 것인가?
//	- 캡슐화 -> 세부적인 구현을 객체의 내부로 숨겼음. -> 의존하는 객체는 해당 객체의 인터페이스에만 의존하게 수정. -> 변경 용이성 개선됨. -> 객체의 자율성이 높아짐.
// 캡슐화와 응집도
//	- 소극장이 단지 판매원이 자신의 메시지에 대한 응답을 할 것이라는 것만 암  -> 밀접히 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임. -> 객체의 응집도가 높음.
//	- 자신의 데이터를 스스로 처리하고 외부의 간섭을 최대한 배제하며 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만듬 -> 훌륭한 객체지향 설계.

// 설계가 왜 필요한가?
//	- 설계가 코드를 작성하는 것보다 높은 차원의 창조적 행위? -> 아니다. 설계와 구현을 떨어트려서 이야기할 수 없다.
//	- 설계는 코드 작성의 일부 -> 코드 작성하지 않고는 검증할 수 없다.
// 	- 좋은 설계 -> 완성해야 하는 기능을 하는 코드를 짜고 내일의 요구사항을 쉽게 반영할 수 있는 설계. -> 요구사항은 항상 변함 그래서 요구사항을 예측? X 쉽게 반영 O -> 기존 코드 변경 X -> 버그 X
