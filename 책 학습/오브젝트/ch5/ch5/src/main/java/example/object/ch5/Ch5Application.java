package example.object.ch5;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Ch5Application {

	public static void main(String[] args) {
		SpringApplication.run(Ch5Application.class, args);
	}

}

// 책임 주도 설계를 향해
//	- 데이터 중심 설계에서 책임 중심 설계로의 전화을 위해서는 두 가지 원칙을 따라야 한다.
//		1. 데이터보다 행동을 먼저 결정해라.
//			-객체에게 중요한 것은 데이터 X 외부에 제공하는 행동 O -> 클라이언트 관점에서 객체가 수행하는 행동 == 책임.
//			- 이를 위한 가장 기본적인 방법은 질문의 순서를 바꾸는 것이다. -> 객체가 수행해야 하는 책임이 뭔가? -> 이 책임을 수행하는데 필요한 데이터는 뭔가?
//		2. 협력이라는 문맥 안에서 책임을 결정해라.
//			- 객체에 할당한 책임의 품질은 협력에 적합한 정도로 결정됨.
//			- 이런 적합한 책임을 할당하기 위해선 메시지를 결정한 후에 객체를 선택 -> 메시지가 존재하기 때문에 그 메시지를 처리해야 할 객체가 필요한 것.
//		=> 객체에게 적절한 책임을 할당 -> 협력이라는 문맥을 고려.
//		=> 메시지를 결정 -> 객체 결정 -> 객체가 가지는 상태
//		- 책임 주도 설계
//			- 책임 주도 설계의 흐름 다음과 같다.
//				- 시스템이 제공하는 기능에 대한 이해.
//				- 이 기능을 더 잘게 쪼개기.
//				- 쪼개진 책임을 어떤 객체에게 할당할지 결정.
//				- 객체가 책임을 수행하다가 다른 책임의 수행이 필요할 때 협력할 객체 찾기.
//				- 해당 객체에게 책임을 할당하여 두 객체가 협력.

// 책임 할당을 위한 GRASP 패턴
//	- General Responsibility Assignment Software Pattern (일반적인 책임 할당을 위한 소프트웨어 패턴) -> 책임 할당 시 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리.
//	- 도메인 개념에서 출발하기
//		- 완벽하게 정리하는 것이 아닌 빠르게 도메인 개념을 정리하고 설계와 구현을 진행하라.
//	- 정보 전문가에게 책임을 할당해라. (Information Expert 패턴)
//		- 애플리케이션이 제공해야 하는 기능을 -> 애플리케이션 책임으로 생각. --> 예로 2장의 영화 예매 서비스이 사용자에게 제공해야 하는 기능은 영화를 예매하는 것.
//			- 메시지를 전송할 객체는 무엇을 원하는가? -> 영화를 예매하는 것.
//			- 메시지를 수신할 적합한 객체는 누구인가? -> 객체 자신이 스스로의 상태를 직접 처리 -> 책임과 책임을 수행하는데 필요한 상태는 동일한 객체 내에 존재.
//		- 객체에게 책임을 할당하는 것 -> GRASP에서는 이를 Information Expert 패턴이라고 부른다.
//		- 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없다.
//		- 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다. -> 어떤 방식이건 정보 전문가가 반드시 데이터를 저장하고 있을 필요없다는 것이 중요.
//		- 아마 예매하라는 메시지를 처리할 책임은 Screening에게 적합할 것이다. -> 이는 영화에 대한 정보, 상영 시간, 상영 순번처럼 예매에 필요한 다양한 정보를 알고있다.
//	- 높은 응집도와 낮은 결합도 (Low Coupling, High Cohesion 패턴)
//		- 설계는 트레이드오프 활동이라는 것을 기억.
//			- 할인 요금 계산 -> Movie가 DiscountCondition에 할인 여부를 판단하라는 메시지를 전송.
//			- 대안 -> movie 대신 Screening이 직접 DiscountCondition과 협력하게 하는 것은 어떨까? -> 이를 위해선 Screening이 DiscountCondition에게 할인 여부를 판단하라는 메시지를 전송하고 반환받은 할인 여부를 Movie에게 전송하도록 수정.
//			- Movie는 전달된 할인 여부 값을 이용해 기본 금액을 이용할지, 아니면 할인 정책에 따라 할인 요금을 계산할지를 결정.
//			- Movie가 DiscountCondition과 협력하는 방법을 선택한 이유
//				- 책임 할당 시 다양한 대안들이 존재 -> 응집도와 결합도 측면에서 더 나은 대안 선택.
//		- Low Coupling 패턴 (낮은 결합도 패턴)
//			- 위에서 언급했던 Screeningdl DiscountCondition과 협력하는 방법은 결합도를 높인다 -> Movie는 애초에 DiscountCondition을 합성하고 있다.
//		- High Cohesion 패턴 (높은 응집도 패턴)
//			- Screening의 가장 중요한 책임은 예매를 생성하는 것 -> DiscountCondition과의 협력 -> 영화 요금 계산과 관련된 책임 일부를 떠안음.
//			- 예매 요금 계산 방식이 변경 -> Screening도 함께 변경해야 하는 것.
//	- 창조자에게 객체 생성 책임을 할당하라. (Creator 패턴)
//		- 영화 예매 협력의 최종 결과물 -> Reservation 인스턴스를 생성하는 것. -> 협력에 참여하는 어떤 객체에게는 이 인스턴스를 생성할 책임을 할당해야 한다는 것.
//		- 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침 제공.
// 			- A를 생성해야 하는 경우 어떤 객체에게 객체 생성 책임을 할당해야 하는가? -> 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당해라.
//				- B가 A 객체를 포함하거나 참조한다.
//				- B가 A 객체를 기록한다.
//				- B가 A 객체를 긴밀하게 사용한다.
//				- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다 (이 경우는 B는 A에 대한 정보 전문가다)
//			- 이 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. -> 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적 결합도에 영향을 미치지 않는다.
//		- 그럼 Reservation을 잘 알고 있거나 긴밀하게 사용하거나 초기화 시 필요한 데이터를 가지고 있는 개체는 뭘까? -> Screening이다. -> 예매 정보 생성을 위한 영화, 상영 시간, 상영 순번 등의 정보에 대한 전문가이며 예매 요금 계산 Movie와도 협력한다.
//	- 대략적으로 책임을 객체들에게 할당했다. -> 올바른 설계일까?? -> 코드를 작성하면 알 수 있다. 코드를 작성해라.

// 책임 주도 설계의 대안
// 	- 책임 관점에서 사고하기 위해선 충분한 경험과 학습이 필요 -> 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것.
//	- 그 후에 명확히 드러나는 책임들을 올바른 위치로 이동시키는 것. -> 주의할 점은 코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안된다는 것이다. -> 이를 리팩토링이라 한다.
//		- 캡슐화를 향상시키고, 응집도를 높이고, 결합도는 낮춰야 하지만 동작이 바뀌면 안된다.
//	- 객체로 책임을 분배할 때 가장 먼저 할 일은 메서드를 응집도 있는 수준으로 분해하는 것이다. -> 각 메서드를 적절한 클래스로 이동하기가 더 수월해진다.
// 객체를 자율적으로 만들자.
//	- 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다.
//	- 어떤 데이터를 사용하는지를 가장 쉽게 알 수 있는 방법은 메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악하는 것이다.
//	- 다른 클래스로 메서드를 이동시킬 때는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적이다. -> 접근자 메서드 없이 데이터에 접근할 수 있고 업데이트 할 수 있다.
//	- 책임 주도 설계 방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩터링하면 유사한 결과를 얻을 수 있다는 것이다. -> 이게 오히려 더 훌륭한 결과물을 낳을 수도 있다.
