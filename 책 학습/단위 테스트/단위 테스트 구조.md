일반적으로 Arrange Act Assert, Given When Then 패턴으로 작성된 단위 테스트 구조를 살펴볼겁니다. 이 장에선 유용하지 않은 테스트 코드 명명 사례를 알아보고 왜 좋지 않은지 살펴보겠습니다. 그리고 좋은 명명 방법을 알아보겠습니다.

## 단위 테스트를 구성하는 방법

### AAA 패턴 사용

테스트 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는데 도움이 됩니다. 이런 일관성이 해당 패턴의 가장 큰 장점 중 하나입니다. 

- Arrange(Given) : 테스트 대상 시스템(SUT)과 해당 의존성을 원하는 상태로 만듭니다.
- Act(When) : SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 출력 값을 캡처합니다.
- Assert(Then) : 결과를 검증합니다.

### 여러 개의 준비, 실행, 검증 구절 피하길

때로 테스트 코드를 짜다보면 아래와 같은 순서로 같은 구절이 여러 개 만들어 지는 경우가 생깁니다.

```
준비구절 -> 실행구절 -> 검증구절 -> 좀 더 실행 -> 다시 검증
```

검증 구절로 구분된 여러 개의 실행 구절을 보면 여러 개의 동작 단위를 검증하는 테스트를 뜻하기에 통합 테스트를 의미하게 됩니다.

통합 테스트의 경우엔 속도를 높이는 방법으로 여러 실행과 검증이 있는 단일한 테스트로 묶는 방법이 있습니다. 하지만 이 최적화 기법은 통합 테스트에만 적용할 수 있고 그것도 전부가 아닌 이미 느리고 더 느려지게 하고 싶지 않은 테스트들만입니다.

단위 테스트나 충분히 빠른 통합 테스트에선 이런최적화가 필요하지 않고 **항상 다단계 단위테스트를 여러 개의 테스트로 나누는 것이 더 좋습니다.**

### 테스트 내 분기문

테스트 내에는 분기문이 들어가지 않는 것이 좋습니다. **테스트에 분기가 있어서 얻는 이점은 없고** 읽고 이해하는 것을 더 어렵게 만들 뿐입니다.

### 각 구절은 얼마나 커야 할까요?

앞에서 언급한 준비, 실행, 검증과 같은 구절은 얼마나 커야할까요? 테스트 이후의 종료 구절은 어떻게 해야할까요?

- 준비 구절이 가장 큰 경우
    - 일반적으로 가장 크며 실행, 검증을 합친 것보다 클수도 있습니다. 그런 경우 **같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출**하는 것이 좋습니다. 이런 **코드 재사용에 도움이 되는 두 가지 패턴으로 오브젝트 마더와 테스트 데이터 빌더**가 있습니다.
- 실행 구절이 한 줄 이상인 경우를 경계하라.
    
    ```java
    customer.purchase(Tomato, 5);
    store.removeInventory(Tomato, 5);
    ```
    
    이런 경우입니다. 실행 구절이 2줄이 되고 purchase 내부적으로 일어나야할 부분이 외부로 빠져있습니다. 클라이언트에게 메서드 호출을 강요하게 됩니다. 이런 경우를 캡슐화가 깨졌다고 말합니다. 무조건 캡슐화를 지킵시다. 근데 유틸 클래스, 인프라 코드의 경우 이런 부분이 덜 적용됩니다.
    

### 검증 구절에는 검증문이 얼마나 있어야 하나요?

- 검증 구절이 너무 커지는 것은 경계해야 합니다.
- 테스트 대상 클래스 내부에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하는 것이 좋습니다. (동등 비교가  가능하게 만드는 것.)

### 종료 단계는 어떤가요?

- 단위 테스트에는 필요없다 (사이드 이펙트가 없기에)
- 통합 테스트의 영역에서 고려해야 하는 부분.

## 테스트 간 테스트 픽스처 재사용

준비 구절에서 코드 재사용은 테스트를 줄이면서 단순화 하기 좋은 방법이고 올바른 방법을 알아봅시다.

앞서 준비 구절이 너무 커지는 경우 별도의 메서드나 클래스로 도출하여 테스트 간 재사용하는 것이 좋다고 했습니다. 그리고 두 가지 방식을 제시했는데 그 중 하나만 유용합니다.

테스트 픽스처 (테스트 실행 대상 객체)를 재사용하는 첫 번째 방법은 각 테스트 이전에 초기화하는 방법입니다. (이 방법은 옳지 않은 방법)

```java
public class Test() {

	private static Customer customer;
	private static Seller seller;

	@BeforeAll
	public static void setup() {
		customer = new Customer();
		seller = new Seller(0;
	}
}
```

이 방법의 두 가지 중요한 단점은 아래와 같습니다.

1. 테스트 간 결합도가 높아진다.
2. 테스트 가독성이 떨어진다.

### 테스트 간 결합도가 높아진다.

테스트 간 높은 결합도는 안티 패턴인데 그 이유는 테스트 픽스처를 수정하면 일부 테스트가 실패하게 됩니다. 이러면 테스트간 연관성이 있다는 뜻이고 단위 테스트의 속성을 어기게 됩니다.

결국 테스트 클래스는 공유 상태를 두면 안됩니다.

### 테스트 가독성을 떨어뜨리는 생성자 사용

이렇게 테스트 생성 시에 픽스처를 만들면 테스트만 보고서는 전체 그림을 볼 수 없습니다. 로직을 이해하려면 텍스트 픽스처를 생성하는 로직 부분을 먼저 들여다 봐야합니다.

### 더 나은 테스트 픽스처 재사용법

```java
public class Test() {
	private Customer CreateCustomer() {
		return new Customer();
	}
} 
```

이런 식으로 내부 private 메소드를 만들고 이를 호출하여 사용합니다. 그럼 테스트 코드에서도 생략되는 부분이 없고 테스트 코드만을 보고도 이해할 수 있습니다.

이 부분은 한 가지 예외가 존재하는데 테스트 전부 또는 대부분에 사용되는 생성자에 픽스처를 인스턴스화할 수 있습니다. DB 연결하는 부분과 같은 부분입니다.

## 단위 테스트 명명법

일반적으로 아래와 같은 명명법을 채택합니다.

```
[테스트 대상 메서드]_[시나리오]_[예상결과]
```

하지만 이런 명명법은 동작이 아닌 구현 세부 사항에 집중하게끔 부추깁니다.

테스트가 정확히 무엇을 검증하고 비즈니스 요구 사항과 어떤 관련이 있는지 파악을 할 수 있는 메서드 명명법을 이용해야 합니다.

그러기 위해선 이와 같은 지침을 따르는 것이 좋습니다.

- 엄격한 명명 정책을 따르지 말고 표현의 자유를 허락하자.
- 비개발자들에게 시나리오를 설명하는 것처럼 테스트명을 짓자.
- 가독성 향상을 위해 단어를 밑줄로 표시해 구분한다.

```java
public void delivery_with_past_date_is_invalid() {
}
```

요런 명명법을 사용하자. 애플리케이션 동작의 관점 중 하나를 설명한다. (배송 가능 여부를 결정하는 관점)

## 매개변수화된 테스트 리팩토링

보통 테스트 하나로 동작 단위를 완전히 설명하기엔 충분치 않다. 그래서 parameterized test를 이용해서 유사한 테스트를 묶을 수 있는 기능을 제공합니다.

매개변수를 이용해서 값을 바꾸면서 테스트 하다 보니까 가장 중요한 부분을 잘 설명할 수 있는 메서드 명명법을 사용하는 것이 좋습니다.

만약 동작이 너무 복잡하다면 매개변수화된 테스트를 조금도 사용해선 안됩니다.
