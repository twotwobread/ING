<aside>
💡 단위테스트에 대해서 자세히 알아보기 전에 단위 테스트를 하기 위해 도움이 되는 목표를 생각해보자.

</aside>

### 단위 테스트의 목표

흔히 단위 테스트를 짜면 더 나은 설계로 이어진다고 하고 이는 사실입니다.

코드베이스에 대해 단위 테스트 작성이 필요하면 일반적으로 더 나은 설계로 이어집니다. 하지만 이건 **단위 테스트의 주 목표가 아니고 사이드 이펙트**일 뿐입니다.

그럼 단위 테스트의 **주 목표**는 뭘까요?? 바로 **소프트웨어 프로그램의 지속적인 성장을 가능케 하는 것**입니다. 일반적으로 모든 프로젝트는 초기에 굉장히 빠르게 성장할 수 있습니다. 테스트가 없다면 더 빠르게 성장할 것입니다. 하지만 테스트가 없는 프로젝트는 시간이 지남에 따라 점점 더 많은 시간을 들여야 처음에 보여준 진척을 보여줄 수 있게 됩니다. 테스트가 있는 프로젝트는 **새로운 기능을 도입**하거나 **새로운 요구 사항에 맞는 리팩토링** 시에 **기존 기능이 잘 작동하는지 확인하는데 시간을 많이 들이지 않게 됩니다.** 이를 위해선 사실 프로젝트 **초반에 노력이 많이 필요**합니다. 하지만 후반에도 잘 성장할 수 있도록 하기에 **장기적으론 그 비용을 메우게 됩니다.**

### 좋은 테스트와 좋지 않은 테스트를 가르는 요인

위에서 말한 것처럼 단위 테스트가 프로젝트 성장에 도움이 되지만 모든 단위 테스트가 그러할까요?? 아닙니다. 잘못 작성한 테스트는 테스트를 작성하지 않는 것과 동일한 결과를 낳습니다. 중요한 것은 **모든 테스트를 작성할 필요가 없다는 것**입니다. 잘못하면 단위 테스트를 작성하는 것을 목표로 잡게 됩니다. 좋은 테스트를 위해선 아래와 같은 요인을 고려해야합니다.

- 기반 **코드 리팩토링 시 테스트도 리팩토링**하라.
- 각 **코드 변경 시 테스트를 실행**하라.
- 테스트가 **잘못된 경고 발생 시 처리**하라.
- 기반 코드가 **어떻게 동작하는지 이해**하려고 할 땐 **테스트를 읽는 데 시간을 투자**하라.

### 제품 코드 대 테스트 코드

사람들이 종종 오해하는 부분이 **제품 코드와 테스트 코드를 다르다고 생각**하고 **테스트 코드가 많으면 좋다**고 생각하지만 **그렇지 않습니다**.  결국 테스트 코드도 코드이고 **많아질수록, 잠재적인 버그에 노출되는 표면적이 넓어지고 유지비용이 증가**합니다. 따라서 **가능한 적은 코드로 문제를 해결하는 것이 좋습니다.** (단위 테스트도 버그에 취약하고 유지보수가 필요합니다.)

### 테스트 스위트 품질 측정을 위한 커버리지 지표

테스트코드가 많을수록 좋은 것이 아니다라는 생각에 추가적으로 더 생각해보겠습니다. 코드 커버리지가 높으면 좋을까요?? 코드 커버리지는 괜찮은 부정 지표이지만 좋지 않은 긍정 지표입니다. 즉, **낮으면 안 좋은 것은 맞지만 높다고 좋은 것은 아닙니다.** 100% 커버리지를 가진다고 양질의 테스트를 제공하는 걸까요?? 예시를 봅시다.

```java
public static bool isStringLong(String input) {
	if (input.length > 5) {
		return true;
	}
	return false;
}

---

public void test() {
	boolean result = isStringLong("abc");
	assertThat(result).isFalse();
}
```

위 코드에 대한 테스트 코드를 작성해봤습니다. 이 때, 코드 길이는 중괄호를 포함해서 5줄이고 그 중에 4줄을 실행하게 되니까 4/5 ⇒ 80%의 라인 커버리지를 가집니다. 근데 만약 `**isStringLong**` 메소드를 아래와 같이 리팩토링 하면 어떻게 될까요??

```java
public static bool isStringLong(String input) {
	return input.length > 5;
}
```

코드 커버리지가 100%로 변하게 됩니다. 내부 로직을 바꾼 것도 아닌데 코드 커버리지가 변하게 됩니다. 이것을 봤을 때 과연 코드 커버리지는 테스트 코드가 양질인지를 판별할 수 있을까요?? **************************************************없습니다.************************************************** 마찬가지로 분기 커버리지는 분기 개수만 다루며 해당 분기를 구현하는데 얼마나 코드가 필요한지 고려하지 않습니다. 분기가 없으면 분기 커버리지는 100퍼가 됩니다.

이외에도 코드 커버리지 지표에는 아래와 같은 문제점이 있습니다.

- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
    - 극단적인 예로는 위에서 말한 테스트를 하고자 하는 코드에 분기가 없다면 분기 커버리지가 100퍼가 됩니다. (근데 실제로는 예외가 발생할수도 있고 그런데도 100퍼가 됩니다.)
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.
    
    ```java
    public static int parse(String input) {
    	return Integer.parseInt(input);
    }
    
    ---
    
    public void test() {
    	int result = parse("5");
    	assertThat(result).isEqualTo(5);
    }
    ```
    
     이 경우 사실 주입되는 값이 5가 아닌 경우도 존재하지만 분기 커버리지는 100퍼가 됩니다. 외부 라이브러리를 이용하면 그 내부의 코드 경로를 고려하지 않습니다.
    

이와 같은 내용을 봐서 **코드 커버리지로 테스트 코드가 양질인지를 판단하는 것은** **잘못되었다**는 것을 알 수  있습니다. → 즉, **코드 커버리지 숫자를 목표로 하는 것도 의미가 없다는 것**입니다.

### 무엇이 성공적인 테스트 스위트를 만드는가?

그럼 테스트 스위트의 품질을 어떻게 측정해야 할까요? 믿을 만한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는 것뿐입니다. 즉, **테스트 스위트가 좋은 지를 자동으로 확인하는 방법은 없다는 것이고 개인 판단에 맡겨야 한다는 것입니다.**

그럼 성공적인 테스트 스위는 어떤 특성을 가질까요?

- **개발 주기에 통합**돼 있다.
    - 자동화된 테스트를 할 수 있는 방법은 **끊임없이 하는 것뿐입니다.** 이상적으로 코드 변경 시마다 아무리 작은 테스트라도 실행해야 합니다.
- 코드베이스에서 **가장 중요한 부분만을 대상**으로 한다.
    - 테스트를 짤때 시스템의 **가장 중요한 부분에 단위 테스트 노력**을 기울이고 **다른 부분은 간략하게 또는 간접적으로 검증하는 것**이 좋습니다. 중요한 부분은 비즈니스 로직이고 다른 모든 부분은 인프라 코드, DB나 서드파티 시스템과 같은 외부 서비스 및 종속성, 모든 것을 하나로 묶는 코드 이 세가지 범주로 나눌 수 있습니다. (물론 이 일부는 단위 테스트를 철저히 해야하는 경우도 있습니다. 매우 중요한 알고리즘이 인프라 코드 내에 있는 경우와 같은 경우에 철저히 테스트 해야합니다. 그러나 **일반적으로 도메인 모델에 초점을 둬야합니다._)**
    - 도메인 모델에 초점을 둔다는 지침을 따르려면 코드베이스 중 중요하지 않은 부분과 도메인 모델을 분리해야합니다. 그래야 **단위 테스트에 대한 노력을 도메인 모델에만 집중이 가능**합니다.
- **최소한의 유지비로 최대의 가치**를 끌어낸다.
    - 결국 이것이 **이 책에서 말하려는 핵심입니다.**
    - 가치 있는 테스트, 가치 없는 테스트를 식별하고 가치 있는 테스트를 작성해야합니다.
    - 이런 가치 있는 테스트를 작성하기 위해선 코드 설계 기술도 알아야 합니다. 단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없습니다. 그렇기에 해당 책에서는 상당 부분을 코드 설계에 할애합니다.
