<aside>
💡 단위 테스트에 접근하는 두 가지 견해에 대해서 알아보자.

</aside>

단위 테스트에 접근하는 방법이 두 가지의 뚜렷한 견해로 나누어 졌는데 각각 **고전파**와 **런던파**로 알려져 있습니다. **고전파는 원론적 접근 방식이고 런던파는 모킹을 이용하는 방법입니다.**

단위 테스트에는 아래와 같은 가장 중요한 3가지 속성이 있습니다. 단위 테스트는

- 작은 코드 조각을 검증하고,
- 빠르게 수행하고,
- **격리된 방식으로 처리하는 자동화된 테스트입니다.**

처음 두 속성은 매우 주관적인 척도이기에 논쟁은 생기지만 논란의 여지는 없습니다. 의견이 크게 다른 부분은 3번째 속성입니다. 이것이 고전파와 런던파를 구분할 수 있게 하는 근원적 차이에 속합니다. 두 분파간의 모든 차이는 **격리가 정확히 무엇인지에 대한 의견 차이** 하나로 시작되었습니다.

### 격리 문제에 대한 런던파의 접근

코드 조각을 격리된 방식으로 검증한다는 것을 런던파에서는 **테스트 대상 시스템을 협력자에게서 격리하는 것**을 일컫습니다. **하나의 클래스가 의존하는 모든 의존성을 테스트 대역으로 대체**합니다. 이를 통해 동작을 외부 영향과 분리해 테스트 대상 클래스에만 집중할 수 있습니다.

이 방법의 **이점**은 테스트 실패 시 **코드베이스의 어느 부분이 고장났는지 확실히 알 수 있다는 것**입니다. (확실히 대상 시스템이 고장난 것) 또 다른 이점은 **객체 그래프를 분할할 수 있다는 것**입니다. 의존성에 또 다른 의존성들이 연결되면서 객체 그래프가 굉장히 복잡해질 수 있는데 이를 테스트 대역을 통해 수행하니까 단순해집니다.  테스트 대역 없이는 전체 객체 그래프를 다시 만드는 방법을 이용해야 합니다. (즉, 테스트 목적의 의존성을 참조하게 대체하는 방식입니다.)

### 고전파 방식과 런던파 방식의 코드 예시

샘플 애플리케이션은 고객이 제품을 구매하는데 상점 재고가 충분하면 구매는 성공하고 재고가 줄어듭니다. 만약 재고가 부족하면 구매는 실패하고 상점엔 아무 일도 일어나지 않습니다. 재고가 충분히 있을 때만 구매가 성공하는지에 대한 검증하는 두 가지 테스트를 **먼저 고전파 방식**으로 짜보겠습니다. (일반적인 3단 구성인 준비, 실행, 검증 패턴을 이용하겠습니다.)

```java
public void purchase_succeeds_when_enough_inventory() {
	// 준비
	var store = new Store();
	store.addInventory(Product.Shampoo, 10);
	var customer = new Customer();

	// 실행
	boolean success = customer.purchase(store, Product.Shampoo, 5);
	
	// 검증
	assertThat(success).isTrue();
	assertThat(store.getInventory(Product.Shampoo)).isEqualTo(5);
}

public void purchase_fails_when_not_enough_inventory() {
	// 준비
	var store = new Store();
	store.addInventory(Product.Shampoo, 10);
	var customer = new Customer(0;

	// 실행
	bool success = customer.purchase(store, Product.Shampoo, 15);

	// 검증
	assertThat(success).isFalse();
	assertThat(store.getInventory(Product.Shampoo)).isEqualTo(15);
}

---

public enum Product {
	Shampoo,
	Book
}
```

준비 부분에서 테스트 대상 시스템과 의존성을 모두 준비하는 부분입니다. 이 경우 Customer가 테스트 대상 시스템 (SUT)에 해당하고 Store가 협력자에 해당합니다. 협력자가 필요한 이유는

- 테스트 대상 메서드를 컴파일하려면 customer.purchase()가 Store 인스턴스를 인수로 필요하기 때문입니다.
- 검증 단계에서 customer.purchase()의 결과 중 하나로 상점 제품 수량이 감소할 가능성이 있기 때문입니다.

고전파 예시로써 협력자를 대체하지 않고 운영용 인스턴스를 사용합니다. Customer만이 아닌 Customer와 Store를 모두 효과적으로 검증합니다. **그러나 Customer 테스트에서 Store가 문제 생겨도 테스트가 실패하기에 테스트에서 두 클래스가 격리되어 있지 않습니다.**

런던파 스타일로 코드를 짜보겠습니다. → Store 인스턴스를 목으로 대체해봅니다.

```java
public void purchase_succeeds_when_enough_inventory() {
	// 준비
	var storeMock = mock(Store.class);
	when(storeMock.hasEnoughInventory(Product.Shampoo, 5)
		.thenReturn(true);
	var customer = new Customer();

	// 실행
	boolean success = customer.purchase(storeMock, Product.Shampoo, 5);

	// 검증
	assertThat(success).isTrue();
	verify(storeMock).hasEnoughInventory(Product.Shampoo, 5);
}

public void purchase_fails_when_enough_inventory() {
	// 준비
	var storeMock = mock(Store.class);
	when(storeMock.hasEnoughInventory(Product.Shampoo, 15)
		.thenReturn(false);
	var customer = new Customer();

	// 실행
	boolean success = customer.purchase(storeMock, Product.Shampoo, 15);

	// 검증
	assertThat(success).isFalse();
	verify(storeMock, never()).removeInventory(Product.Shampoo, 15);
}
```

고전파 방식과는 다르게 모킹을 이용합니다. 샴푸 재고를 추가해서 Store 상태를 수정하느 대신 특정 메서드 호출에 어떻게 응답하는지 목에 직접 정의합니다. → **Store의 실제 상태와 관계없이 테스트가 요구하는 방식으로 요청에 응답합니다.**

지금은 협력자에서 **격리된 테스트 대상 시스템에는 인터페이스가 필요하다는 점**만 알아둡시다. (구체 클래스도 목으로 만들 수 있지만, 안티 패턴입니다.)

중요한 차이점은 여전히 이전과 같이 customer.purchase() 호출 결과를 확인하지만 고객이 상점에서 올바르게 했는지 확인하는 방법이 다릅니다. **이전에는 상점 상태를 검증**했지만 **지금은 Customer와 Store 간의 상호 작용을 검사합니다**. **즉, 고객이 상점에서 호출을 올바르게 했는지 확인합니다**. 고객이 상점으로 호출해야 하는 **메서드 뿐만 아니라 호출 횟수까지도 검증**할 수 있습니다.

### 격리 문제에 대한 고전파의 접근

고전적인 방법으로 격리 특성을 해석하는 방법이 있습니다. 코드를 격리하지 않고 테스트하는 것이다 대신 단위 테스트는 서로 격리해서 실행해야 합니다. 이렇게 하면 테스트를 어떤 순서(병렬이나 순차 등)로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않습니다.

각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 이상 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻입니다. 이를 통해 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있습니다. DB, 파일 시스템 등 프로세스 외부 의존성이 이러한 공유 상태의 대표적인 예입니다.

예를 들어, 어떤 테스트 준비 단계에서 DB에서 고객을 생성할수도 있고 삭제할수도 있는데 이 두 가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데 이는 제품 코드가 고장 나서가 아니라 두 번째 테스트의 간섭 때문입니다.

격리 문제에 대한 이런 견해는 목과 기타 테스트 대역의 사용에 대한 훨씬 더 평범한 견해를 수반합니다. 테스트 대역을 사용할 수 있지만, **보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용합니다.**

### 단위 테스트의 런던파와 고전파

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |

### 고전파와 런던파의 비교

다시 말하면, 고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있습니다. 이는 결국 테스트해야 할 단위의 처리와 의존성 취급에 대한 방법으로 넘어갑니다.

**책 저자는 단위 테스트 고전파를 선호**하는데  이는 고품질의 테스트를 만들고 단위 테스트의 궁극적인 목표인 **프로젝트 지속 가능한 성장을 달성하는데 더 적합합니다.** 그 이유는 취약성에 있습니다. 목을 사용한 테스트는 고전적인 테스트보다 불안정한 경향이 있습니다. 지금은 런던파의 주요 장점을 하나씩 살펴봅시다.

- 입자성이 좋습니다. 테스트가 세밀해서 한 번에 한 클래스만 확인합니다.
- 의존 클래스 그래프가 커져도 테스트하기 쉽습니다. 모든 협력자는 모킹되기에 걱정할 필요가 없습니다.
- 테스트 실패 시 어떤 기능이 실패했는지 확실히 알 수 있습니다.  물론 테스트 대상 시스템이 값 객체를 사용하는 상황이 있을 수 있으며, 이 값 객체의 변경으로 인해 테스트가 실패하기도 하지만 테스트 내 다른 의존성을 모두 제거했기에 흔하지 않은 상황입니다.

### 한 번에 한 클래스만 테스트하기

런던파는 클래스를 단위로 간주하는데 이런 경향은 이해되지만 오해의 소지가 있습니다. 테스트는 코드 단위로 짜면 안되고 동작 단위로 구성되어야 합니다. 문제 영역에  의미가 있는 단위를 검증해야합니다. 이를 위해 클래스가 얼마나 필요한지는 상관없습니다. 단위가 여러 클래스에 걸쳐있을 수 있고 반대로 아주 작은 메서드가 될 수 있습니다.

**테스트는 해결하는데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 개발자가 아닌 일반 사람들에게 응집도가 높고 의미가 있어야합니다.**

강아지를 부르면 나에게 온다 vs 강아지를 부르면 앞발을 움직이고 그 뒤에 그 뒷발을 같이 움직이며…. 어쩌구 저쩌구해서 내 앞에 도착한다.

뭐가 더 말이 되나요?? 전자인 것 같습니다. 실제 동작(주인에게 온다) 대신 개별 클래스(다리)를 목표로 할 때 테스트가 이렇게 보이기 시작합니다.

### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

모킹을 하면 복잡한 의존 객체 그래프를 단순화 할 수 있어 테스트하기 편리합니다. (직접적 의존성을 대체하기 때문)

사실 이 부분은 잘못도니 문제에 초점을 맞추고 있습니다. 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는게 아니고 이런 클래스 그래프를 갖지 않는데 집중해야 합니다. 결국 이부분은 코드 설계의 문제인거죠.

이 부분은 좋은 부정 지표로써 작동할 수 있습니다. 고전파 방법으로 테스트 의존성으로 객체 그래프를 구성할 때 그게 해야할 일이 커진다면 코드 설계가 잘못되었구나를 느낄 수 있습니다. 하지만 모킹을 하면 이런 문제를 감추기만 할 뿐 원인을 해결하지 못합니다.

### 버그 위치 정확히 찾아내기

고전파 방식을 이용하게 되면 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하기 때문에 문제 원인을 찾기가 힘들어집니다. 하지만 큰 문제가 아닙니다. 테스트를 정기적으로 실행한다면 버그의 원인을 알아낼 수 있습니다. 즉, 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 그리 어렵지 않습니다. 

게다가 이런 계단식 실패가 가치가 있습니다. 버그가 테스트 하나뿐만 아니라 많은 테스트에서 결함으로 이어진다면, 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여줍니다. 즉, 전체 시스템이 그것에 의존합니다.

### 고전파와 런던파 사이의 다른 차이점

- TDD를 통한 시스템 설계 방식
- 과도한 명세 문제

런던파 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작합니다. 모킹을 통해서 협력자를 지정하고 구현전까지 클래스 그래플르 다져갑니다. 

고전파 단위 테스트는 실제 객체를 다뤄야 하기에 지침을 똑같이 두지 않습니다. 상향식을 이용하고 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둡니다.

여기서 가장 중요한 차이점은 과도한 명세 문제입니다. 즉 테스트가 SUT의 구현 세부 사항에 결합되는 것입니다. 런던 스타일이 더 자주 결합되는 편이라서 런던 스타일과 목을 전반적으로 아무 곳이나 사용하는 것에 대해 주로 이의가 제기됩니다.

### 두 분파의 통합 테스트

두 분파 간 통합 테스트에 대한 정의에도 차이가 있습니다. 격리에 대한 정의가 다르기에 자연스럽게 다른 의견으로 이어진 것입니다.

런던파는 실제 협력자 객체를 이용하는 모든 테스트를 통합 테스트로 간주합니다. 그래서 고전 스타일의 테스트 대부분이 모키스트들에겐 통합 테스트로 느껴질겁니다.

먼저 고전파 관점에서의 단위 테스트의 정의는

- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리한다 입니다.

통합 테스트는 이런 기준 중 하나를 충족하지 않는 테스트입니다. DB와 같은 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없습니다. 이런 테스트는 순차적으로 실행해 각 테스트가 공유 의존성과 함께 작동할 수 있습니다.

마찬가지로 외부 의존성에 접근하면 테스트가 느려집니다.

마지막으로 둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트입니다. 이는 종종 테스트 스위트의 실행 속도를 최적화하려는 노력의 결과입니다. 그 이유는 비슷한 단계를 따르지만 다른 동작 단위를 검증하는 느린 테스트가 두 개 있을 때, 하나로 합치는 것이 타당할 수 있습니다. 원래 이 두 테스트는 통합 테스트 (느려서)였기에 일반적으로 결정적인 특징은 아닙니다. 또한 다른 팀이 개발한 모듈이 둘 이상 있는 경우 통합 테스트로 어떻게 동작하는지 검증할 수 있습니다. 

### 통합 테스트의 일부인 엔드 투 엔드 테스트

간단히 말해 통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트이고 엔드 투 엔드 테스트는 통합 테스트의 일부입니다. 이 테스트도 프로세스 외부 종속성과 함께 어떻게 동작하는지 검증합니다. 통합 테스트와의 차이점은 엔트 투 엔트 테스트가 의존성을 더 많이 포함한다 정도입니다.

엔드 투 엔드 테스트는 일반적으로 모든 의존성을 다 들고 작동하는데 그래서 모든 외부 애플리케이션을 포함하여 최종 사용자의 관점에서 검증하는 것을 의미합니다.

예로써 애플리케이션에서 DB, 파일 시스템, 결제 게이트웨이라는 세 가지 프로세스 외부 의존성이 작동한다고 가정하면 통합 테스트는 결제는 모킹하고(DB, 파일 시스템은 완전 제어가 가능하지만 결제는 그렇지 않음) 나머지 의존성을 실제 객체로써 사용합니다. 근데 엔드 투 엔드 테스트는 그냥 모두 실제 객체를 이용하는 방법입니다. 이는 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋습니다.

하지만 사실 엔드 투 엔드도 프로세스 외부 읜존성을 처리하지 못하는 경우도 있어 통합 테스트와의 뚜렷한 경계가 없다는 사실을 강조합니다.
