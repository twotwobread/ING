<aside>
💡 테스트에서 목을 사용하는 것은 논란의 여지가 있는 주제임.
목으로 인해 리팩터링 내성이 부족한 테스트를 초래하는 경우와 리팩터링 내성 저하 없이 목을 사용하는 방법을 살펴보자.

</aside>

## 목과 스텁 구분

테스트 대역 유형은 목, 스텁, 더미, 페이크, 스파이 이렇게 5개의 유형이 존재하지만 크게 목과 스텁으로 구분함.

- 목 : 외부로 나가는 상호 작용을 모방하고 검사하는데 도움이 됨. 이런 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당.
- 스텁 : 내부로 들어오는 상호 작용을 모방하는데 도움이 됨. 이런 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당.

### 도구로서의 목과 테스트 대역으로서의 목

우리는 목을 이용할 때 목 라이브러리를 이용하는데 이를 도구로서의 목이라고 함. 도구로서의 목을 이용하여 목, 스텁 이 두 가지 유형의 테스트 대역 모두를 생성할 수 있기에 목을 혼동하지 않는 것이 중요함. 아래의 예시는 목이 아닌 스텁임.

```java
public void createReport() {
	var stub = mock(IDatabase.class);
	when(stub.getNumberOfUsers()).thenReturn(10); // 준비한 응답설정
	var sut = new Controller(stub);

	Report report = sut.createReport();

	assertThat(report).isEqualTo(10);
}
```

내부로 들어오는 상호 작용, 즉 sut에 입력 데이터를 제공하는 호출을 모방함. 반면 아래 예제는 외부로 나가는 호출에 대한 상호 작용이고 그 목적은 사이드 이펙트를 일으키는 것(이메일 발송)뿐임.

```java
public void sendGreetingsEmail() {
	var mock = mock(IEmailGateWay.class);
	var sut = new Controller(mock);

	sut.greetUser("user@email.com");
	
	verify(mock).sendGreetingsEmail();
}
```

### 스텁으로 상호 작용을 검증하지 말라

기존에 얘기했던 부분이 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종 결과를 검증하는 것이라 했는데 스텁의 결과는 최종 결과가 아닌 이를 도출하기 위한 수단이다. 그렇기에 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 안티패턴이다. 최종 결과가 아닌 사항을 검증하는 이런 관행을 과잉 명세라고 부른다. 목은 더 복잡하다 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만 대다수가 그렇다. 뒤에서 얘기해보자.

### 목과 스텁 함께 쓰기

떄로는 이 두 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다. 예를 들면 이전에 나왔던 아래의 예시이다.

```java
public void purchaseFailsWhenNotEnoughInventory() {
	var storeMock = mock(IStroe.class);
	when(storeMock.hasEnoughInventory(Product.Shampoo, 5))
		.thenReturn(false);
	var sut = new Customer();
	
	boolean success = sut.purchase(storeMock, Product.Shampoo, 5);

	assertThat(success).isFalse();
	verify(storeMock, never()).removeInventory(Product.Shampoo, 5);
}
```

해당 테스트는 두 가지 목적으로  storeMock을 사용한다. 준비된 응답을 반환하고 sut에서 수행한 메서드 호출을 검증한다. 그러나 이는 서로 다른 메서드이다.

1. hasEnoughInventory()에서 응답을 설정
2. removeInventory()에 대한 호출을 검증.

→ 스텁을 상호작용 하지 말라는 규칙도 위배되지 않음.

→ 이는 목이면서 스텁이지만 목이라고 부르지 스텁이라 하지 않는다. 목이라는 사실이 스텁이라는 사실보다 더 중요하기에 대체로 목이라 한다.

### 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

이 두 개념은 명령 조회 분리 (CQS, Command Query Separation) 원칙과 관련이 있다. CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며 혼용해선 안된다. 명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드이다. 사이드 이펙트의 예로 객체 상태 변경, 파일 시스템 내 파일 변경 등이 있다. 조회는 반대로 사이드 이펙트가 없고 반환 값이 있다. 이 원칙을 따르고자 할 경우 반환타입이 void인지 확인해라. 또 질문 시엔 답이 달라져선 안된다. 이렇게 명확히 분리하면 코드를 읽기 쉽다. 

물론 항상 이 원칙을 따를 수 있는 것은 아니다. 전형적인 예로 stack.pop()인데 사이드 이펙트(맨 위 값을 빼냄)가 있으면서 반환 값(빼낸 맨 위 값)이 존재한다. 그래도 가능할때마다 CQS 원칙을 따르는 것이 좋다.

명령을 대체하는 테스트 대역은 목이다. 조회는 스텁이다. 

## 식별할 수 있는 동작과 구현 세부 사항

앞에서 말했듯 리팩터링 내성 지표는 이진 선택이기에 가장 중요하다. 따라서 테스트가 단위 테스트 영역에 있고 엔드 투 엔드 테스트 범주로 바뀌지 않는 한 리팩터링 내성을 최대한 활용하는 것이 좋다. 엔드 투 엔드 범주로 넘어가면 리팩터링 내성이 가장 뛰어나도 일반적으로 유지 보수하기가 훨씬 까다롭다.

거짓 양성이 있는 이유는 테스트가 구현 세부 사항과 결합돼 있기 때문이란 걸 알았다. 이를 위해선 테스트가 어떻게가 아닌 무엇을에 중점을 둬야 한다. 그럼 구현 세부 사항이 정확히 뭐고 식별할 수 있는 동작과 어떻게 다를까?

### 식별할 수 있는 동작은 공개 API와 다르다.

식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.

- 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출하라. (연산 = 계산 수행 or 사이드 이펙트를 초래, 둘다 가능)
- 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라. (상태 = 시스템의 현재 상태)

구현 세부 사항은 이 두 가지 중 아무것도 하지 않음. 즉, 식별할 수 있는 동작이기 위해선 목표 중 하나라도 직접적 관계가 있어야함.

이상적으로 시스템의 공개 API = 식별할 수 있는 동작. 그리고 모든 구현 세부 사항은 비공개되어야 함. 이런 시스템은 API 설계가 잘돼 있다고 말함.

### 구현 세부 사항 유출 : 연산의 예

예를 들어서 User 클래스 내부에 유저 이름이 50자를 초과하면 잘라야한다는 불변 속성이 있다.

```java

@Getter
@Setter
public class User {

    public String name;

    public String normalizeName(String name) {
        String result = name.trim();

        if (result.length() > 50) {
            return result.substring(0, 50);
        }

        return result;
    }
}

public class UserController {

    public void renameUser(int userId, String newName) {
        User user = userRepository.findById(userId);
        
        user.name = user.normalizeName(newName);
        
        userRepository.save(user);
    }
}
```

완벽한 코드가 아니지만 이해해주길 바랍니다. UserController는 클라이언트 코드이고 renameUser 메서드에서 user 클래스를 사용한다. 이 메서드의 목표는 사용자의 이름을 바꾸는 것이다.

그럼 여기서 User 클래스의 API가 잘 설계되지 않은 이유는 무엇일까? 속성과 메서드를 보면 둘 다 공개다. API를 잘 설계하기 위해선 해당 멤버가 식별할 수 있는 동작이 되게 해야 한다. 이를 위해 두 가지 중 하나를 해야한다.

- 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출하라. (연산 = 계산 수행 or 사이드 이펙트를 초래, 둘다 가능)
- 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라. (상태 = 시스템의 현재 상태)

name 속성만 이 요구 사항을 만족한다. 사용자 이름 변경이라는 목표를 달성할 수 있도록 setter를 노출한다. UserController가 nomalizeName 메서드를 호출하는 이유는 그냥 불변 속성을 만족시키기 위함이다. 그래서 공개되면 안되는 구현 세부 사항이란 것이다. 바꿔보면 아래와 같다.

```java
@Getter
public class User {

    private String name;

		public User(String name) {
			setName(name);
		}

    private String normalizeName(String name) {
        String result = name.trim();

        if (result.length() > 50) {
            return result.substring(0, 50);
        }

        return result;
    }

		public void setName(String newName) {
			this.name = normalizeName(newName);
		}
}

public class UserController {

    public void renameUser(int userId, String newName) {
        User user = userRepository.findById(userId);
        
        user.setName(newName);
        
        userRepository.save(user);
    }
}
```

요런 느낌 구현의 세부 사항들이 밖으로 드러나지 않는다. 만약 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.

### 잘 설계된 API와 캡슐화

캡슐화는 불변성 위반이라고도 하는 모순을 방지하는 조치이다. 불변성 위반으로 구현 세부 사항을 노출하게 된다. 즉, 구현 세부 사항을 노출하면 불변성 위반을 가져온다.

장기적으로 코드 유지 보수에 캡슐화가 중요한 이유는 코드 복잡도 때문이다. 이는 소프트웨어 개발에서 가장 큰 어려움 중 하나이다. 코드베이스가 복잡해질수록 작업도 어려워지고 속도도 느려지고 버그도 증가한다. 

이를 대처하기 위해선 캡슐화 밖에 방법이 없다. 해당 코드로 할 수 있는 것과 할 수 없는 것을 명확히 알려주지 않으면 코드 변경 시 모순이 생긴다. 이를 위해선 최대한 부담을 덜어라. 개발자가 실수할 수 있는 옵션조차 제공하지 않도록 하는 것이다.

캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다. 즉 지속적인 성장을 가능하게 하는 목표인 것이다. tell-don’t-ask라는 유사한 원칙이 있다. 구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 목표이다.

- 구현 세부 사항을 숨기면 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

모든 구현 세부사항을 비공개로 하면 테스트에서 식별할 수 있는 동작을 검증하는 것 외에 다른 선택지가 없기에 리팩터링 내성도 자동으로 좋아진다. → API를 잘 설계하면 단위테스트도 자동으로 좋아진다.

## 목과 테스트 취약성 간의 관계

이 절에선 육각형 아키텍처, 내부 통신과 외부 통신의 차이점 그리고 목과 테스트 취약성 간의 관계를 알아본다.

### 육각형 아키텍처 정의

전형적인 애플리케이션은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다. 도메인 계층에 비즈니스 로직이 포함돼 있다.

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다. RESTfull API인 경우 모든 요청이 이 계층에 도달한다. 이 계층은 도메인 클래스와 프로세스 외부 의존성 간의 작업을 조정한다.

- DB 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
- 해당 인스턴스에 연산 호출
- 결과를 DB에 다시 저장

애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형성하며 애플리케이션을 나타낸다. 또한 다른 애플리케이션과 소통할 수 있다. (여기서 다른 애플리케이션은 SMTP 서비스, 서드파티 시스템, 메시지 버스 등이 될 수 있음.)

이 육각형 아키텍처의 목적은 세 가지 중요한 지침을 강조하는 것이다.

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
    - 비즈니스 로직은 애플리케이션에서 가장 중요한 부분 → 도메인 계층은 이에 대한 모든 책임 but 다른 모든 책임에서는 제외
    - 반대로 애플리케이션 서비스엔 어떤 비즈니스 로직도 존재 X
    - 도메인 계층은 애플리케이션의 도메인 사용 방법 모음으로써 애플리케이션 서비스 계층을 일련의 비즈니스 유스케이스로 볼 수 있음.
- 애플리케이션 내부 통신
    - 이 아키텍처는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정함.
    - 도메인 계층 내부 클래스는 지네끼리 의존하고 애플리케이션 서비스 계층의 클래스에 의존하지 않음.
    - 계층 간 관심사를 분리하는 것은 애플리케이션 서비스 계층이 도메인 계층에 대해 아는 것을 의미하지만 반대는 아님. 도메인 계층은 외부 환경에서 완전히 격리.
- 애플리케이션 간의 통신
    - 외부 애플리케이션은 애플리케이션 서비스 계층의 공통 인터페이스를 통해 해당 애플리케이션에 연결됨.
    - 아무도 도메인 계층에 직접적인 접근 불가.

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함함. 예를 들어 도메인 계층의 식별할 수 있는 동작은 이 계층의 연산과 상태이고 이는 애플리케이션 서비스 계층이 적어도 하나의 목표를 달성하는데 도움이 됨.

잘 설계된 API의 원칙엔 프랙탈 특성이 있는데 이는 전체 계층만큼 크게도, 단일 클래스만큼 작게도 똑같이 적용되는 것. → 각 계층의 API를 잘 설계 시 테스트도 프랙탈 구조를 갖게됨. 즉, 달성 목표는 같지만 서로 다른 수준에서 동작을 검증함.

각 테스트는 의미 있는 이야기를 전달해야 하고 그렇지 않으면 구현 세부 사항과 결합돼 있기에 불안정하다는 강한 암시다.

식별할 수 있는 동작은 바깥 계층에서 안쪽으로 흐른다. 외부 클라이언트에게 중요한 목표는 개별 도메인 클래스에서 달성한 하위 목표로 변환된다. 따라서 도메인 계층에서 식별할 수 있는 동작은 구체적인 비즈니스 유스케이스와 연관성이 있다. 이는 재귀적으로 추적이 가능하다. (추적성은 식별할 수 있는 동작의 정의를 따름)

앞에서 나왔던 아래 예시는 좋은 예이다.

```java
@Getter
public class User {

    private String name;

		public User(String name) {
			setName(name);
		}

    private String normalizeName(String name) {
        String result = name.trim();

        if (result.length() > 50) {
            return result.substring(0, 50);
        }

        return result;
    }

		public void setName(String newName) {
			this.name = normalizeName(newName);
		}
}

public class UserController {

    public void renameUser(int userId, String newName) {
        User user = userRepository.findById(userId);
        
        user.setName(newName);
        
        userRepository.save(user);
    }
}
```

여기서 UserController가 애플리케이션 서비스이다. 외부 클라이언트가 사용자 이름을 정규화하는 것과 같은 특정 목표가 없고 전적으로 애플리케이션 제약에 의해 모든 이름을 정규화한다고 가정하면 User 클래스의 normalizeName 메서드는 클라이언트의 요구 사항으로 추적할 수 없다. 따라서 구현 세부 사항이고 비공개 해야한다. 또한 테스트에서 이 메서드를 직접 확인하면 안된다. (식별할 수 있는 기능만 검증해야함.)

코드베이스의 공개 API를 항상 비즈니스 요구 사항에 따라 추적하라는 지침은 대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만, 유틸리티나 인프라 코드에는 적용되지 않는다. 해당 코드로 해결하는 문제는 종종 너무 낮은 수준이고 세밀해서 구체적인 비즈니스 유스케이스로 추적할 수 없다.

### 시스템 내부 통신과 시스템 간 통신

- 시스템 내부 통신 : 애플리케이션 내 클래스 간의 통신
- 시스템 간 통신 : 애플리케이션과 다른 애플리케이션 간의 통신

→ 시스템 내부 통신은 구현 세부 사항이고 시스템 간 통신은 그렇지 않음. 

시스템 내부 통신은 식별할 수 있는 동작와 직접적인 연관이 없기에 구현 세부 사항이고 그래서 이런 협력을 테스트에서 검증하면 안됨.

반면 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타냄. 이는 애플리케이션에 항상 있어야 하는 계약임.

이런 스스템간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯됨. 성장의 주요 원칙 중 하나로 하위 호환성을 지키는 것이다. 외부와의 통신은 항상 외부 애플리케이션이 이해할 수 있게 유지가 되어야함. 예를 들어, 메시지 버스로 전송하느 메시지의 구조를 지키고 SMTP 서비스 호출은 매개변수의 유형과 개수등을 맞추는 것과 같이.

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다. 반대로 시스템 내 클래스 간 통신에 목을 이용하면 구현 세부 사항과 결합하게 되고 리팩터링 내성 지표가 미흡해진다.

### 시스템 내부 통신과 시스템 간 통신의 예

시스템 내부 통신과 시스템 간 통신의 차이점을 예로써 설명. 이전에 등장했던 Customer, Store를 예로 설명. 다음 비즈니스 유스케이스를 보라.

- 고객이 상점에서 제품을 구매하려함.
- 매장 내 제품 수량이 충분하면
    - 재고가 상점에서 줄어든다.
    - 고객에게 이메일로 영수증을 발송한다.
    - 확인 내역을 반환한다.

CustomerController 클래스는 도메인 클래스와 외부 애플리케이션 (SMTP 서비스의 프록시인 EmailGateway)간의 작업을 조정하는 애플리케이션 서비스임.

```java
public class CustomerController {
	public boolean purchase(int customerId, int productId, int quantity) {
		Customer customer = customerRepository.findById(customerId);
		Product product = productRepository.findById(productId);
		
		boolean isSuccess = customer.purchase(
						mainStore, product, quantity);
		
		if (isSuccess) {
			emailGateway.sendReceipt(
				customer.email, product.name, quantity);
		}
		
		return isSuccess;
	}
}
```

purchase 메서드에서 고객은 상점에 재고가 충분한지 확인하고 충분하면 제품 수량을 감소한다고 가정하자.

구매라는 동작은 시스템 내부 통신과 시스템 간 통신이 모두 있는 비즈니스 유스케이스이다. 시스템 간 통신은 CustomerController 애플리케이션 서비스와 두 개의 외부 시스템인 서드파티 애플리케이션(유스케이스를 시작하는 클라이언트이기도 함)과 이메일 게이트웨이 간의 통신이다. 시스템 내부 통신은 Customer, Store 도메인 클래스 간의 통신이다.

이 예제에서 SMTP 서비스에 대한 호출은 외부 환경에서 볼 수 있는 사이드 이펙트이므로 애플리케이션에 전체적으로 식별할 수 있는 동작을 나타냄. 또한 고객의 목표와 직접적인 연관이 있음. 애플리케이션의 클라이언트는 서드파티 시스템이다. 이 시스템의 목표는 구매를 하는 것이며 고객이 성공적인 결과로서 이메일로 확인 내역을 받는 것을 기대함.

SMTP 서비스에 대한 호출을 목으로 하는 이유는 타당하다. 리팩터링 후에도 이러한 통신 유형이 그대로 유지되도록 하기 때문에 테스트 취약성을 야기하지 않음. 

```java
public vodi successfulPurchase() {
	var mock = mock(IEmailGateWay.class);
	var sut = new CustomerController(mock);
	
	boolean isSuccess = sut.purchase(
		1, 2, 5); // customerId, productId, quantity
	
	assertThat(isSuccess).isTrue();
	verify(mock, times(1)).sendReceipt( // 시스템이 구매에 대한 영수증을 보내는지 검증.
								"customer@email.com", "Shampoo", 5);
}
```

isSuccess 플래그는 외부 클라이언트에서도 확인할 수 있으며 검증도 필요하다. 하지만 이 플래그는 목이 필요 없고 간단한 값 비교만으로 충분하다.

이제 Customer 클래스와 Store 클래스 간의 통신에 목을 사용한 테스트를 살펴보자.

```java
public vodi successfulPurchase() {
	var storeMock = mock(IStore.class);
	when(storeMock.hasEnoughInventory(Product.Shampoo, 5))
		.thenReturn(true);
	var customer = new Customer();

	boolean success = customer.purchase(
		storeMock Product.Shampoo, 5);
	
	assertThat(success).isTrue();
	verify(storeMock, times(1))
		.removeInventory(
			Product.Shampoo, 5);
}
```

이전과 달리 이는 애플리케이션 경계를 넘지 않음. 호출자랑 수신자가 모두 애플리케이션 내부에 존재함. 또한 이 메서드는 클라이언트가 목표를 달성하는데 도움이 되는 연산이나 상태가 아님. 이 두 도메인 클래스의 클라이언트는 구매를 목표로 하는 CustomerController이다. 이 목표에 직접적인 관련이 있는 멤버는 customer.purchase()와 store.getInventory() 이렇게 둘뿐이다. purchase 메서드는 구매가 시작하고 getInventory() 메서드는 구매가 완료된 후 시스템 상태를 보여준다. removeInventory() 메서드 호출은 고객의 목표로 고객의 목표로 가는 중간 단계 (구현 세부 사항)에 해당한다.

### 단위 테스트의 고전파와 런던파 재고

- 단위 테스트의 고전파와 런던파 간 차이점

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |

이전 저자는 고전파를 더 선호한다고 했는데 그 이유는 런던파는 불변 의존성 외의 모든 의존성에 목 사용을 권장한다 → 시스템 내 통신과 시스템 간 통신을 구분하지 않는다. → 테스트는 외부 시스템 과의 통신을 확인하는 것처럼 클래스 간 통신도 확인함.

이렇게 목을 무분별하게 사용 시 구현 세부 사항과 결합돼 테스트에 리팩터링 내성이 없게 된다.

반면 고전파는 테스트 간 공유하는 의존성 (대부분이 SMTP 서비스나 메시지 버스 등 프로세스 외부 의존성에 해당)만 교체하자고 하므로 이 문제에 훨씬 유리하다. 그러나 고전파 역시 시스템 간 통신에 대한 처리에 이상적이진 않다. 런던파만큼은 아니지만 고전파도 목 사용을 지나치게 장려한다.

### 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다.

먼저 의존성 유형에 대해 다시 훑어보자.

- 공유 의존성 : 테스트 간 공유하는 의존성
- 프로세스 외부 의존성 : 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성 (ex. DB, 메시지 버스, SMTP 서비스 등)
- 비공개 의존성 : 공유하지 않는 모든 의존성

고전파에서도 공유 의존성을 피할 것을 권고한다. → 테스트가 실행 컨텍스트를 서로 방해하고 결국 병렬 처리가 불가능해진다. → 테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것을 테스트 격리라고 부른다.

공유 의존성이 프로세스 외부에 있는 것이 아니면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 써서 재사용을 피하기 쉽다. 공유 의존성이 외부에 있으면 테스트가 더 복잡해진다. 각 테스트 실행 전에 DB를 인스턴스화하거나 메시지 버스를 새로 준비할수가 없다. (테스트 스위트가 완전 느려짐.) 일반적 접근법은 이런 의존성을 테스트 대역, 즉 목과 스텁으로 교체하는 것이다.

그러나 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다. 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있다면 이런 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다. 실제로 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션 일부로 작용한다.

애플리케이션과 외부 시스템 간의 토신패턴을 항상 지켜야 하는 요구 사항은 하위 호환성을 지켜야 한다는 점에서 비롯된다. 애플리케이션이 외부 시스템과 통신하는 방식을 지켜야 한다. 애플리케이션과 외부 시스템을 동시에 변경할 수 없기 때문이다. 또한 배포 주기가 다르거나 단순히 제어 권한이 없을 수 있기 때문이다.

그러나 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없다면 하위 호환성 요구 사항은 사라진다. 이제 이 외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않을 것이다. 이런 시스템의 통신 패턴은 구현 세부 사항이 된다.

좋은 예로는 애플리케이션 DB가 있다. 애플리케이션에서만 사용되는 DB다. 어떤 외부 시스템도 이 DB에 접근할 수 없다. 따라서 기존 기능을 손상시키지 않는 한 시스템과 애플리케이션 DB 간의 통신 패턴을 원하는 대로 수정할 수 있다. 해당 DB는클라이언트의 시야에서 완전 숨어있기에 전혀 다른 저장 방식으로 대체할 수 있고 그렇게 해도 아무도 모를 것이다.

완전 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다. DB에서 테이블을 분할하거나 저장 프로시저에서 매개변수 타입을 변경할 때마다 테스트가 빨간색이 되는 것을 아무도 원하지 않는다. DB와 애플리케이션은 하나의 시스템으로 취급해야 한다.

이것은 분명히 문제가 될 수 있다. 피드백 속도를 저하시키지 않고 어떻게 이런 의존성으로 테스트할까??

### 목을 사용한 동작 검증

종종 목이 동작을 검증한다고 한다. 하지만 대부분이 그렇지 않다. 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가 없다.

클래스 간의 통신을 검증하는 것은 두뇌의 뉴런이 서로 통과하는 신호를 측정해 사랑의 행동을 유추하는 것과 유사하다. 이러한 세부 수준은 너무 세밀하다. 중요한 것은 클라이언트 목표를 거슬러 올라갈 수 있는 동작이다. 클라이언트는 도움을 청할 때 두뇌의 어떤 뉴런이 켜지는지 신경 쓰지 않는다. 클라이언트에게 중요한 것은 도움뿐이다. 물론 신뢰할 수 있고 전문적인 방식일 것이다. 목은 애플리케이션 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 사이드 이펙트가 외부 환경에서 보일 때만 동작과 관련이 있다.
