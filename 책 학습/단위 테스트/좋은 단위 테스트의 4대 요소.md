<aside>
💡 앞전 1장에서는 좋은 단위 테스트 스위트의 특성을 살펴봄  
  
  - 개발 주기에 통합되어 있다.
  - 코드베이스의 가장 중요한 부분만을 대상으로 한다.
  - 최소한의 유지비로 최대 가치를 끌어낸다.

앞에서 배운 것과 같은 가치있는 테스트를 식별하는 것과 작성하는 것은 별개의 기술이다.
그렇기에 해당 장에선 먼저 가치있는 테스트를 식별하는 방법을 알아보자.
</aside>

먼저 좋은 단위 테스트의 4대 요소를 알아보겠습니다.

1. 회귀 방지
2. 리팩토링 내성
3. 빠른 피드백
4. 유지 보수성

### 회귀 방지

기능이 많아지고 코드가 많아질수록 회귀 발생율이 올라갑니다. 그래서 이런 회귀에 대해 효과적인 보호를 개발하는 것이 중요한데요. 회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하기 위해선 다음 사항을 고려해야합니다.

- 테스트 중 실행되는 코드 양
- 코드 복잡도
- 코드의 도메인 유의성

코드가 예외를 발생시키지 않는지도 중요하지만 생성하는 결과가 유효한지도 확인해야합니다.

그리고 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드보다 훨씬 더 중요합니다.

가장 큰 피해를 입힐 코드이기 때문입니다!!

반면 그저 단순히 코드를 테스트하는 것은 가치가 없습니다. 마지막으로 우리가 작성하지 않은 코드 (외부 라이브러리들)도 중요합니다. 테스트 범주에 포함시켜 의존성에 대해 검증이 올바른지 확인해야합니다.

### 리팩터링 내성

한번 상상을 해봅시다. 새로운 기능을 개발했고 그에 따라 짠 테스트 코드도 모두 통과가 됩니다. 이 때 리팩터링할 곳이 보입니다. 요기랑 조기만 고치면 좋을꺼 같은데 이런 생각이 듭니다. 하지만 고치는 순간 테스트가 실패합니다. 아무리 살펴봐도 리팩터링을 해도 기능이 고장나지 않는데 테스트는 실패합니다.

이런 상황을 거짓 양성이라고 말합니다. 다른 말로 허위 경보입니다. 실제로 기능이 잘 동작하지만 테스트는 실패하는 경우를 일컫습니다. 왜 거짓 양성 발생을 신경써야 할까요?? 전체 테스트 스위트에 치명적 영향을 줄 수 있기 때문입니다. → 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것입니다.

근데 거짓 양성은 이를 방해합니다.

- 테스트의 장점은 조기 경고를 제공한다는 점인데 문제가 없는데 경고를 보내기 시작하면 이를 무시하게 되어 진짜 경고를 반환해도 무시하게 되어 성장을 더디게 만듭니다.
- 또 다른 테스트의 장점인 코드 변경이 회귀로 이어지지 않음을 확신하게 만들어 주는 부분도 이런 확신, 신뢰를 깨버려서 성장을 더디게 만듭니다.

어떻게 해결할까요?? 리팩터링을 하지 않을까요?? 올바른 대응은 테스트 스위트를 다시 살펴보고 안정성을 높이기 시작하는 것입니다. 나중에 알아보겠습니다.

### 거짓 양성의 원인

거짓 양성의 원인이 뭘까요?? 이는 테스트 구성 방식과 연관이 있습니다. 테스트와 SUT의 구현 세부사항이 결합할수록 거짓양성이 더 많이 생기게 됩니다.

이를 피하기 위해선 SUT의 구현을 검증하는 것이 아니라 사용자 관점에서 SUT를 검증해야 합니다. 즉, 최종 사용자에게 의미 있는 결과만 확인하고 다른 모든 것은 무시해야 합니다.

### 구현 세부 사항 대신 최종 결과를 목표로 하기

SUT와 테스트 간 결합도를 낮추기 위해선 세부 사항이 아닌 최종 결과를 목표로 해야합니다. 예를 들어, 특정 HTML 페이지를 렌더링하는 메서드가 있다고 했을 때 구현 세부 사항에 집중하는 검증방식은 그 HTML 내용에 대한 검증을 하는 방식입니다. 최종 결과에 집중하는 방식은 메시지가 브라우저에 표시되는 방식을 검증하는 방식입니다. 이런 방식의 검증은 거짓 양성이 거의 없을 것입니다.

### 첫 번째 특성과 두 번째 특성 간의 본질적 관계

좋은 단위 테스트의 두 요소 회귀 방지와 리팩터링 내성 사이엔 본질적인 관계가 있습니다. 정반대의 관점에서 테스트 스위트의 정확도에 기여합니다. 

테스트 스위트의 정확도 지표는 다음과 같은 두 요소로 구성됩니다.

1. 테스트가 버그 있음을 얼마나 잘 나타내는가 (거짓 음성 (회귀 방지 영역) 제외).
2. 테스트가 버그 없음을 얼마나 잘 나타내는가 (거짓 양성(리팩터링 내성 영역) 제외).

이를 수식으로 나타내면

$$
테스트 정확도 = \frac{신호(발견 버그 수)}{소음(허위 경보 발생 수}
$$

즉, 테스트 정확도를 향상시키는 방법은 분자, 신호를 증가시키는 것(회귀를 더 잘 찾아내는 것)과 분모, 소음을 줄이는 것(허위 경보를 발생시키지 않는 것)입니다.

### 거짓 양성과 거짓 음성의 중요성 : 역학 관계

우리는 보통 테스트를 짜다보면 거짓 음성인 회귀 방지에만 중점을 두게 됩니다. 초기에는 회귀 방지가 테스트 스위트에 주는 영향도가 더 큽니다. 그 이유는 거짓 양성은 리팩터링 내성과 관련되어 있기에 리팩터링이 없는 프로젝트 초반엔 영향력이 적습니다. 하지만 프로젝트가 진행될수록 거짓 양성의 영향력은 기하급수적으로 커집니다. 그렇기에 거짓 음성과 거짓 양성에 대해서 똑같은 주의를 기울여야 합니다.

### 세 번째 요소와 네 번째 요소 : 빠른 피드백과 유지 보수성

- 빠른 피드백
- 유지 보수성

테스트가 빠르면 피드백 루프를 대폭 줄여서 버그 수정 비용을 거의 0까지 줄일 수 있습니다. 그리고 유지 보수성 지표는 유지비를 평가합니다.

- 테스트가 얼마나 이해하기 어려운가? 이는 테스트 크기와 관련있고 라인이 적을수록 더 읽기 쉽습니다. 하지만 단지 라인 수를 줄이기 위한 인위적 압축은 오히려 가독성을 떨어뜨립니다. 그리고 테스트 코드의 품질은 제품 코드만큼 중요합니다. 테스트를 작성할 땐 절차를 생략하면 안됩니다. 테스트 코드를 **일급 시민**으로 취급해야합니다.
- 테스트가 얼마나 실행하기 어려운가? 테스트가 프로세스 외부 종속성으로 작동하면 DB 서버 재부팅, 네트워크 문제 해결 등 의존성을 상시 운영하는데 시간을 들여야 합니다.

### 이상적 테스트를 만드는 것은 가능한가?

결론부터 얘기하면 불가능합니다. 처음 3가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호배타적이기 때문입니다. 하나의 특성을 100퍼를 채우기 위해선 무조건 다른 특성이 손해를 보게 됩니다. 따라서 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 합니다. 하나의 특성의 가치가 0으로 수렴된 테스트를 예시로 가져왔습니다.

1. 엔드 투 엔드 테스트 : 많은 이점들을 가지고 있지만 하나의 큰 단점이 있는데 바로 느린 속도입니다. 이는 피드백을 빠르게 받을 수 없기에 개발 팀의 큰 걸림돌이고 이것이 엔드 투 엔드 테스트만으로 코드베이스를 다룰 수 없는 이유입니다.
2. 간단한 테스트 : 너무 단순해서 고장이 절대 없을 것 같은 작은 코드 조각을 다루는 테스트 입니4다. 이는 우수한 리팩터링 내성과 빠른 피드백을 주지만 회귀 방지가 없습니다.
3. 깨지기 쉬운 테스트 : 이는 회귀를 방지하고 빠르게 실행되지만 리팩터링 내성이 안좋습니다.
- 결론
    - 이 세 가지 특성 중 두 가지를 극대화하는 테스트를 만들기는 쉽지만 한 특성이 희생해야합니다. 이는 곱셈 규칙을 따라서 하나의 특성이 0이 되면 모두 0이 됩니다. 그럼 어떻게 희생하는 것이 좋을까요?? 모두 조금씩 양보하는게 좋을까요?? 실제로는 리팩터링 내성을 포기할 수 없습니다. 그리고 나머지 두 특성 사이에서 조율을 해야합니다.
    - 그 이유는 테스트가 리팩터링 내성을 갖고 있는지 여부는 이진 선택입니다. 있거나 없거나. 포기 하려면 완전 포기해야 합니다. 하지만 다른 두 특성은 조절이 가능합니다.

### 테스트 피라미드

모든 계층에서 리팩터링 내성은 무조건 챙깁니다. 그리고 빠른 피드백과 회귀 방지 사이에서의 절충을 해야합니다. 단위 테스트 → 통합 테스트 → 엔드 투 엔드 테스트로 이동을 하면서 빠른 피드백은 약해지고 회귀 방지가 강해집니다. 이는 팀 바이 팀이라 할 수 있겠지만 사실 일반적으로 피라미드 형태를 유지해야 합니다. 꼭대기가 엔드 투 엔트 테스트, 밑바닥이 단위 테스트입니다. 즉, 단위 테스트가 제일 많아야 하고 엔드 투 엔드가 제일 적어야 한다는 의미입니다.

엔드 투 엔드가 적어야 하는 이유는 빠른 피드백이 매우 낮은 점수를 받게 되고 또 유지 보수성이 결여됩니다. 따라서 엔드 투 엔드 테스트는 가장 중요한 기능에 적용할 때와 단위테스트나 통합 테스트와 동일한 수준으로 보호할 때만 적용됩니다.

### 블랙박스 테스트와 화이트박스 테스트 간의 선택

- 블랙 박스 테스트 : 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 테스트 방법입니다. 일반적으로 명세와 요구 사항 즉 구현이 아닌 기능을 중심으로 구축됩니다.
- 화이트 박스 테스트 : 정반대입니다. 애플리케이션 내부 작업을 검증하는 테스트 방식이고 소스 코드에서 파생됩니다.

|  | 회귀 방지 | 리팩터링 내성 |
| --- | --- | --- |
| 블랙박스 테스트 | 좋음 | 나쁨 |
| 화이트박스 테스트 | 나쁨 | 좋음 |

기본적으로 블랙박스 테스트를 따르고 문제 영역에 의미 있는 동작을 확인하게 해야합니다. 화이트박스 테스트는 테스트를 분석할 시 사용하는 것이 좋을 것 같습니다.
